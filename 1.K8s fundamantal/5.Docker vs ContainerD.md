Notes: https://notes.kodekloud.com/docs/Kubernetes-and-Cloud-Native-Associate-KCNA/Kubernetes-Fundamentals/Docker-vs-ContainerD

![[Pasted image 20250911221923.png]]
# Why K8S use ContainerD than Docker ?

- K8S would like to use Container Runtime interface (CRI)
- Docker born before CRI ,so docker doesn't support CRI
- K8S use ContainerD or other Container Runtime is supported by VRI
- before 1.24 use dockershim, 
- Why docker images work in k8s before 1.24?
	- docker images follow image spec in open container standard

# ContainerD

## Architect
![[Pasted image 20250911222825.png]]


## CLI Tools
![[Pasted image 20250911223108.png]]

### ctr
- use for debugging containerd
- Not very use friendly
- limited features
```bash
ctr images pull docker.io/library/redis:alpine
ctr run docker.io/library/redis:alpine redis
```

### nerdctl
- like Docker CLI for containerd
- support docker compose
- newest features
	- Encrypted container images
	- Lazy pulling
		- ดึงและเรียกใช้ image ของ container ที่ไม่จำเป็นต้องดาวน์โหลด image ทั้งหมดตั้งแต่ต้น
	- P2P Images Distribution
		- เครื่องที่ดาวน์โหลด image ไปแล้วจะเปลี่ยนสถานะเป็น **"peer"** และสามารถส่งต่อ (seed) ส่วนของ image ที่ตนเองมีให้กับ peer เครื่องอื่นๆ ที่กำลังดาวน์โหลดอยู่ได้
		- ช่วยลดภาระของ registry server และใช้ประโยชน์จากแบนด์วิธของเครื่องต่างๆ ในเครือข่ายเดียวกัน
		- เมื่อมีหลายๆ peer ในเครือข่ายเดียวกัน การดาวน์โหลดจะเร็วกว่าการดึงจาก server ส่วนกลางเพียงอย่างเดียว
	- Image signing and verifying
	- Namespaces in Kubernetes
	
```bash
# Simply replace the Docker command with nerdctl
nerdctl run --name redis redis:alpine
nerdctl run --name webserver -p 80:80 -d nginx
```


### crictl
- Cli for container runtime created by Container Runtime Interface
- Manual install
- Used to inspect and debug container runtimes 
- Works across different runtimes
- develop by k8s community

basic command
```bash
crictl pull busybox
crictl images
crictl ps -a
crictl exec  -it <containerid> ls
crictl logs <containerid> 
crictl pods

	  ```

connect runtime
```bash
crictl --runtime-endpoint
export CONTAINER_RUNTIME_ENDPOINT=<your_runtime_endpoint>
```

valid endpoints
```bash
• unix:///run/containerd/containerd.sock
• unix:///run/crio/crio.sock
• unix:///var/run/cri-dockerd.sock
```
